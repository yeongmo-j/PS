"
[문제요약]
각 계단의 점수가 배열로 들어오는데,
계단은 한칸 혹은 두칸씩 오를 수 있고, 세칸 연속은 불가능하다.
이때, 마지막 계단은 꼭 밟아야 할 때, 계단 밟은 점수의 최대값을 구하여라.

[해결방법]
dp bottom up으로 풀었다.
d[i][k]를 정의. i번째 계단을 k했을 때(k=0이면 안밟음. k=1이면 밟음) 얻을 수 있는 최대 점수
d[i][0]은 안밟을 때임. 그런데 계단은 최대 두칸밖에 못건너니까, 앞에 계단은 꼭 밟아야 함.
그러므로 d[i][0] = d[i-1][1]이 된다.
d[i][1]은 밟을 때임. 그러나 세칸 연속으로 밟을 수는 없다.
그러므로 밟-안밟-밟 케이스 (d[i][1] = d[i-2][1]+A[i])
안밟-밟-밟 케이스 (d[i][1] = d[i-2][0]+A[i-1]+A[i]) 둘중에 더 큰게 d[i][1]이 된다.

마지막 계단은 밟아야 하므로, 정답은 d[n][1]이 된다.

Time complexity : O(N)
Space complexity : O(N);

[추가]

@@@@@@@@@@@@@
아예 d[i][k]를 새로 정의. d[i][k]는 i번째 계단이 k번 연속으로 밟은 계단이다. 로 정의
k=0인 경우 : 0번 연속인 계단이다. : 불가능
k=1인 경우 : 1번 연속인 계단이다 : 전전계단 밟고 두칸을 한번에 밟은 계단이다. : d[i-2][1~2]중 최대값 + A[i]
k=2인 경우 : 2번 연속인 계단이다 : d[i-1][1]+A[i] 가 된다.

@@@@@@@ 일차원 배열로 해결하기
d[i]는 i번째 계단에 올라섰을 때, 얻을 수 있는 최대점수로 정의하면
전전전꺼 밟고 전전꺼 안밟고, 전에꺼 밟고, 지금꺼 밟기
전전꺼 밟고 전에거 안밟고 지금꺼 밟기 이 두개의 케이스밖에 나오지 못한다
d[i] = d[i-3] + A[i-1] + A[i]
d[i] = d[i-2] + A[i] 두개 중 큰걸 고르면 된다.
"

import java.util.Scanner;

public class Main {
	public static void main(String[] args)
	{
		Scanner scin = new Scanner(System.in);
		int n = scin.nextInt();
		int[] A = new int[n+1];
		int i, j;
		for (i=1 ; i<=n ; i++)
			A[i] = scin.nextInt();
		int[][] d = new int[n+1][2];
		d[1][0] = 0;
		d[1][1] = A[1];
		if (n>=2) {
			d[2][0] = d[1][1];
			d[2][1] = d[1][1] + A[2];
		}
		for (i=3 ; i<=n ; i++) {
			d[i][0] = d[i-1][1];
			d[i][1] = Math.max(d[i-2][1]+A[i], d[i-2][0]+A[i-1]+A[i]);
		}

		System.out.println(d[n][1]);
		scin.close();
	}
}

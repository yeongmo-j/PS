'''
[문제요약]
정수가 하나 주어지고
[1,N]
사이에서 아래로 뒤집었을 때, 제대로된 숫자이며 숫자가 바뀌었을 때, 이때 카운트 해서 총 카운트 갯수 반환
0,1,8은 뒤집으면 그대로고,
2는 5, 6은 9로 바뀐다.

[해결방법]
하나하나 뒤집어준 다음에, 비교하였다.

Time complexity : O(NlogN);
Space complexity : O(logN)

[추가]
@@@@좋은방법@@@@@@@
너무 오래걸린다.
dp로 더욱 빠르게 할 수 있음.
3개의 케이스로 나눈다
dp[i]=0 if불가능한수
dp[i]=1 if같은수
dp[i]=2 if가능한데, 다른수일경우

그래서 1부터 N까지 계산해가며 dp[i]를 저장한다
일의자리는 다 저장이 가능 한데
문제는 십의자리부터이다.
이때는, 이 수를 i/10과 i%10으로 나눈다!!
(십의자리 이상의 수와 일의자리의 수) -> 결국 둘 다 이전에 구해놓은 수 이므로,
dp가 가능하다
결국. i/10과 i%10이 둘다 1이면 1로 바꾸고,
둘다 1이 넘고 ,둘중에 하나라도 2면, 2로 바꾼다.
아니면 안되는 수 이므로 그대로 0으로 놔둔다(초기값)

2로 저장시킬 때마다 1씩 더해서 결과를 리턴한다.
'''
public int rotatedDigits(int N) {
    int[] dp = new int[N + 1];
    int count = 0;
    for(int i = 0; i <= N; i++){
        if(i < 10){
            if(i == 0 || i == 1 || i == 8) dp[i] = 1;
            else if(i == 2 || i == 5 || i == 6 || i == 9){
                dp[i] = 2;
                count++;
            }
        } else {
            int a = dp[i / 10], b = dp[i % 10];
            if(a == 1 && b == 1) dp[i] = 1;
            else if(a >= 1 && b >= 1){
                dp[i] = 2;
                count++;
            }
        }
    }
    return count;
}
